/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (() => {

eval("const DEFAULT_MAX_COL_WIDTH = 500;\nconst DEFAULT_COLS = 'auto';\nconst DEFAULT_DEBOUNCE_MS = 300;\nconst DEFAULT_GAP_PX = 24;\nconst ELEMENT_NODE_TYPE = 1;\n\nconst COL_COUNT_CSS_VAR_NAME = `--_masonry-layout-col-count`;\nconst GAP_CSS_VAR_NAME = `--_masonry-layout-gap`;\n\nconst $template = document.createElement('template');\n$template.innerHTML = `\n   <style>\n\n     :host {\n       display: flex;\n       align-items: flex-start;\n       justify-content: stretch;\n     }\n     .column {\n     max-width: calc((100% / var(${COL_COUNT_CSS_VAR_NAME}, 1) - ((var(${GAP_CSS_VAR_NAME}, ${DEFAULT_GAP_PX}px) * (var(${COL_COUNT_CSS_VAR_NAME}, 1) - 1) / var(${COL_COUNT_CSS_VAR_NAME}, 1)))));\n     width: 100%;\n       flex: 1;\n       display: flex;\n       flex-direction: column;\n     }\n     .column:not(:last-child) {\n       margin-right: var(${GAP_CSS_VAR_NAME}, ${DEFAULT_GAP_PX}px);\n     }\n     .column ::slotted(*) {\n       margin-bottom: var(${GAP_CSS_VAR_NAME}, ${DEFAULT_GAP_PX}px);\n       box-sizing: border-box;\n       width: 100%;\n     }\n     #unset-items {\n       opacity: 0;\n       position: absolute;\n       pointer-events: none;\n     }\n   </style>\n   <div id=\"unset-items\">\n     <slot></slot>\n   </div>\n `;\n\nconst DEBOUNCE_MAP = new Map();\n\n/**\n * Returns a number attribute from an element.\n * @param $elem\n * @param name\n * @param defaultValue\n */\nfunction getNumberAttribute($elem, name, defaultValue) {\n  const value = parseFloat($elem.getAttribute(name) || '');\n  return isNaN(value) ? defaultValue : value;\n}\n\nfunction getColCount(totalWidth, cols, maxColWidth) {\n  return isNaN(cols) ? Math.max(1, Math.ceil(totalWidth / maxColWidth)) : cols;\n}\n\n/**\n * Debounces a function.\n * @param cb\n * @param ms\n * @param id\n */\nfunction debounce(cb, ms, id) {\n  const existingTimeout = DEBOUNCE_MAP.get(id);\n  if (existingTimeout != null) window.clearTimeout(existingTimeout);\n  DEBOUNCE_MAP.set(id, window.setTimeout(cb, ms));\n}\n\n/**\n * Returns the index of the column with the smallest height.\n * @param colHeights\n */\nfunction findSmallestColIndex(colHeights) {\n  let smallestIndex = 0;\n  let smallestHeight = Infinity;\n  colHeights.forEach((height, i) => {\n    if (height < smallestHeight) {\n      smallestHeight = height;\n      smallestIndex = i;\n    }\n  });\n\n  return smallestIndex;\n}\n\nclass MasonryLayout extends HTMLElement {\n  static get observedAttributes() {\n    return ['maxcolwidth', 'gap', 'cols'];\n  }\n\n  set maxColWidth(v) {\n    this.setAttribute('maxcolwidth', v.toString());\n  }\n\n  get maxColWidth() {\n    return getNumberAttribute(this, 'maxcolwidth', DEFAULT_MAX_COL_WIDTH);\n  }\n\n  /**\n   * The amount of columns.\n   * @attr cols\n   * @param v\n   */\n  set cols(v) {\n    this.setAttribute('cols', v.toString());\n  }\n\n  get cols() {\n    return getNumberAttribute(this, 'cols', DEFAULT_COLS);\n  }\n\n  /**\n   * The gap in pixels between the columns.\n   * @attr gap\n   * @param v\n   */\n  set gap(v) {\n    this.setAttribute('gap', v.toString());\n  }\n\n  get gap() {\n    return getNumberAttribute(this, 'gap', DEFAULT_GAP_PX);\n  }\n\n  /**\n   * The ms of debounce when the element resizes.\n   * @attr debounce\n   * @param v\n   */\n  set debounce(v) {\n    this.setAttribute('debounce', v.toString());\n  }\n\n  get debounce() {\n    return getNumberAttribute(this, 'debounce', DEFAULT_DEBOUNCE_MS);\n  }\n\n  /**\n   * The column elements.\n   */\n  get $columns() {\n    return Array.from(this.shadowRoot.querySelectorAll(`.column`));\n  }\n\n  // Unique debounce ID so different masonry layouts on one page won't affect eachother\n  debounceId = `layout_${Math.random()}`;\n\n  // Reference to the default slot element\n  $unsetElementsSlot;\n\n  ro = undefined;\n\n  // The current request animation frame callback\n  currentRequestAnimationFrameCallback = undefined;\n\n  /**\n   * Attach the shadow DOM.\n   */\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.appendChild($template.content.cloneNode(true));\n\n    this.onSlotChange = this.onSlotChange.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this.layout = this.layout.bind(this);\n\n    this.$unsetElementsSlot = this.shadowRoot.querySelector('#unset-items > slot');\n  }\n\n  /**\n   * Hook up event listeners when added to the DOM.\n   */\n  connectedCallback() {\n    this.$unsetElementsSlot.addEventListener('slotchange', this.onSlotChange);\n\n    // Attach resize observer so we can relayout eachtime the size changes\n    if ('ResizeObserver' in window) {\n      this.ro = new ResizeObserver(this.onResize);\n      this.ro.observe(this);\n    } else {\n      window.addEventListener('resize', this.onResize);\n    }\n  }\n\n  /**\n   * Remove event listeners when removed from the DOM.\n   */\n  disconnectedCallback() {\n    this.$unsetElementsSlot.removeEventListener('slotchange', this.onSlotChange);\n    window.removeEventListener('resize', this.onResize);\n    if (this.ro != null) {\n      this.ro.unobserve(this);\n    }\n  }\n\n  /**\n   * Updates the layout when one of the observed attributes changes.\n   */\n  attributeChangedCallback(name) {\n    switch (name) {\n      case 'gap':\n        this.style.setProperty(GAP_CSS_VAR_NAME, `${this.gap}px`);\n        break;\n    }\n\n    // Recalculate the layout\n    this.scheduleLayout();\n  }\n\n  /**\n   *\n   */\n  onSlotChange() {\n    // Grab unset elements\n    const $unsetElements = (this.$unsetElementsSlot.assignedNodes() || []).filter(\n      (node) => node.nodeType === ELEMENT_NODE_TYPE\n    );\n\n    // If there are more items not yet set layout straight awy to avoid the item being delayed in its render.\n    if ($unsetElements.length > 0) {\n      this.layout();\n    }\n  }\n\n  /**\n   * Each time the element resizes we need to schedule a layout\n   * if the amount available columns has has changed.\n   * @param entries\n   */\n  onResize(entries) {\n    // Grab the width of the element. If it isn't provided by the resize observer entry\n    // we compute it ourselves by looking at the offset width of the element.\n    const { width } =\n      entries != null && Array.isArray(entries) && entries.length > 0\n        ? entries[0].contentRect\n        : { width: this.offsetWidth };\n\n    // Get the amount of columns we should have\n    const colCount = getColCount(width, this.cols, this.maxColWidth);\n\n    // Compare the amount of columns we should have to the current amount of columns.\n    // Schedule a layout if they are no longer the same.\n    if (colCount !== this.$columns.length) {\n      this.scheduleLayout();\n    }\n  }\n\n  /**\n   * Render X amount of columns.\n   * @param colCount\n   */\n  renderCols(colCount) {\n    // Get the current columns\n    const $columns = this.$columns;\n\n    // If the amount of columns is correct we don't have to add new columns.\n    if ($columns.length === colCount) {\n      return;\n    }\n\n    // Remove all of the current columns\n    for (const $column of $columns) {\n      $column.parentNode && $column.parentNode.removeChild($column);\n    }\n\n    // Add some new columns\n    for (let i = 0; i < colCount; i++) {\n      // Create a column element\n      const $column = document.createElement(`div`);\n      $column.classList.add(`column`);\n      $column.setAttribute(`part`, `column column-${i}`);\n\n      // Add a slot with the name set to the index of the column\n      const $slot = document.createElement(`slot`);\n      $slot.setAttribute(`name`, i.toString());\n\n      // Append the slot to the column an the column to the shadow root.\n      $column.appendChild($slot);\n      this.shadowRoot.appendChild($column);\n    }\n\n    // Set the column count so we can compute the correct width of the columns\n    this.style.setProperty(COL_COUNT_CSS_VAR_NAME, colCount.toString());\n\n    // Commit the changes for ShadyCSS\n    window.ShadyCSS && window.ShadyCSS.styleElement(this);\n  }\n\n  /**\n   * Schedules a layout.\n   * @param ms\n   */\n  scheduleLayout(ms = this.debounce) {\n    debounce(this.layout, ms, this.debounceId);\n  }\n\n  /**\n   * Layouts the elements.\n   */\n  layout() {\n    // Cancel the current animation frame callback\n    if (this.currentRequestAnimationFrameCallback != null) {\n      window.cancelAnimationFrame(this.currentRequestAnimationFrameCallback);\n    }\n\n    // Layout in the next animationframe\n    this.currentRequestAnimationFrameCallback = requestAnimationFrame(() => {\n      // console.time(\"layout\");\n\n      // Compute relevant values we are going to use for layouting the elements.\n      const gap = this.gap;\n      const $elements = Array.from(this.children).filter((node) => node.nodeType === ELEMENT_NODE_TYPE);\n      const colCount = getColCount(this.offsetWidth, this.cols, this.maxColWidth);\n\n      // Have an array that keeps track of the highest col height.\n      const colHeights = Array(colCount).fill(0);\n\n      // Instead of interleaving reads and writes we create an array for all writes so we can batch them at once.\n      const writes = [];\n\n      // Go through all elements and figure out what column (aka slot) they should be put in.\n      // We only do reads in this for loop and postpone the writes\n      for (const $elem of $elements) {\n        // Read the height of the element\n        const height = $elem.getBoundingClientRect().height;\n\n        // Find the currently smallest column\n        let smallestColIndex = findSmallestColIndex(colHeights);\n\n        // Add the height of the item and the gap to the column heights.\n        // It is very important we add the gap since the more elements we have,\n        // the bigger the role the margins play when computing the actual height of the columns.\n        colHeights[smallestColIndex] += height + gap;\n\n        // Set the slot on the element to get the element to the correct column.\n        // Only do it if the slot has actually changed.\n        const newSlot = smallestColIndex.toString();\n        if ($elem.slot !== newSlot) {\n          writes.push(() => ($elem.slot = newSlot));\n        }\n      }\n\n      // Batch all the writes at once\n      for (const write of writes) {\n        write();\n      }\n\n      // Render the columns\n      this.renderCols(colCount);\n\n      // Commit the changes for ShadyCSS\n      window.ShadyCSS && window.ShadyCSS.styleElement(this);\n\n      // console.timeEnd(\"layout\");\n    });\n  }\n}\n\ncustomElements.define('masonry-layout', MasonryLayout);\n\n\n//# sourceURL=webpack://js_internship/./index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.js"]();
/******/ 	
/******/ })()
;